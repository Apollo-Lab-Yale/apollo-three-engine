<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from "../../js/utils/utils_three.js";
    import {TransformGizmoEngine} from "../../js/utils/utils_transform_gizmo.js";
    import {BSpline} from "../../js/utils/utils_splines.js";
    import {arclength_parameterize_spline_interpolate} from "../../js/utils/utils_splines.js";
    import {identity_matrix} from "../../js/utils/utils_math.js";
    import {get_default_lil_gui} from "../../js/utils/utils_three.js";
    import {unroll_matrix_to_list} from "../../js/utils/utils_math.js";
    import {get_arclength_components} from "../../js/utils/utils_splines.js";
    import {sub_matrix_matrix} from "../../js/utils/utils_math.js";
    import {normalized_matrix} from "../../js/utils/utils_math.js";
    import {cross_product} from "../../js/utils/utils_math.js";
    import {get_x_rotation_so3_matrix} from "../../js/utils/utils_euler_angles.js";
    import {mul_matrix_matrix} from "../../js/utils/utils_math.js";
    import {add_matrix_matrix} from "../../js/utils/utils_math.js";
    import {mul_matrix_scalar} from "../../js/utils/utils_math.js";
    import {determinant3x3} from "../../js/utils/utils_math.js";

    let engine = ThreeEngine.new_default_3d();

    let tge = new TransformGizmoEngine(engine);

    let settings = {

    };

    let spline = new BSpline(
        [
            [[1], [0], [0], [0]],
            [[0.75], [0.25], [0], [0]],
            [[0.25], [0.75], [0], [0]],
            [[0], [1], [0], [0]],
            [[-0.25], [0.75], [0], [0]],
            [[-0.75], [0.25], [0], [0]],
            [[-1], [0], [0], [0]],
            [[-0.75], [-0.25], [0], [0]],
            [[-0.25], [-0.75], [0], [0]],
            [[0], [-1], [0], [0]],
            [[0.25], [-0.75], [0], [0]],
            [[0.75], [-0.25], [0], [0]],

            [[1], [0], [0], [0]],
            [[0.75], [0.25], [0], [0]],
            [[0.25], [0.75], [0], [0]],
        ],
        3,
        true
    );

    let num_distinct_control_points = spline.control_points.length-3;

    let angle_sliders = [ ];
    let gui = get_default_lil_gui();
    for(let i = 0; i < num_distinct_control_points; i++) {
         settings['angle_'+i.toString()] = 0;
        angle_sliders.push(gui.add(settings, 'angle_'+i.toString(), -3.14, 3.14));
    }

    for(let i = 0; i < spline.control_points.length; i++) {
        let idx = tge.add_gizmo_SO3_matrix_and_position(engine, identity_matrix(3), spline.control_points[i], 0.2);
        let tc = tge.transform_controls[idx];

        tc.addEventListener('change', () => {
            let idx = i % num_distinct_control_points;
            let angle = settings['angle_'+idx.toString()];
            let [rotation, position] = tge.get_gizmo_pose_as_SO3_matrix_and_position(idx);
            let p = unroll_matrix_to_list(position);
            spline.update_control_point(i, [ [p[0]], [p[1]], [p[2]], [angle] ]);
        });
    }

    for(let i = 0; i < angle_sliders.length; i++) {
        angle_sliders[i].onChange(angle => {
            let idx = i;
            let [rotation, position] = tge.get_gizmo_pose_as_SO3_matrix_and_position(idx);
            let p = unroll_matrix_to_list(position);
            spline.update_control_point(i, [ [p[0]], [p[1]], [p[2]], [angle] ]);
            if (idx < 3) {
                spline.update_control_point(num_distinct_control_points + i, [ [p[0]], [p[1]], [p[2]], [angle] ]);
            }
        });
    }

    engine.animation_loop(function() {
        let components = get_arclength_components(spline, spline.control_points.length-1);

        // let components2 = get_arclength_components(spline2, spline2.control_points.length-1);
        let points = [];
        let ts = [];
        for(let i = 0; i <= 150; i++) {
            let t = (i / 150) * (spline.control_points.length-1);
            t = Math.min( t, (spline.control_points.length-1)-0.0001 );
            ts.push(t);
            points.push(arclength_parameterize_spline_interpolate(t, spline, spline.control_points.length-1, components));
            // angles.push(arclength_parameterize_spline_interpolate(t, spline2, spline2.control_points.length-1, components2));
        }

        let vec3s = [];
        let angles = [];
        points.forEach(point => {
            let p = unroll_matrix_to_list(point);
            vec3s.push( [ [p[0]], [p[1]], [p[2]] ] );
            angles.push( p[3] );
        });

        let normalized_tangents = [];
        for(let i = 0; i < ts.length; i++) {
            let p1 = vec3s[i];
            let point2 = unroll_matrix_to_list(spline.interpolate(ts[i] + 0.0000001));
            let p2 = [ [point2[0]], [point2[1]], [point2[2]] ];
            let diff = sub_matrix_matrix(p2, p1);
            let normalized = normalized_matrix(diff);
            normalized_tangents.push(normalized);
        }

        let frames = [];
        for(let i = 0; i < normalized_tangents.length; i++) {
            let x = normalized_tangents[i];
            let y = cross_product(x, [[0], [0], [1]]);
            y = normalized_matrix(y);
            let z = cross_product(x, y);
            z = normalized_matrix(z);
            x = unroll_matrix_to_list(x);
            y = unroll_matrix_to_list(y);
            z = unroll_matrix_to_list(z);

            let frame = [
                [x[0], y[0], z[0]],
                [x[1], y[1], z[1]],
                [x[2], y[2], z[2]]
            ];
            // console.log(determinant3x3(frame));

            // let angle = angles[i];
            // let r = get_x_rotation_so3_matrix(angle);
            // frame = mul_matrix_matrix(frame, r);

            frames.push(frame);
        }

        for(let i = 0; i < vec3s.length-1; i++) {
            let frame = frames[i];
            let y = [ [frame[0][1]], [frame[1][1]], [frame[2][1]] ];
            let scaled_y = mul_matrix_scalar(y, 0.02);
            let scaled_y_n = mul_matrix_scalar(y, -0.02);

            let frame2 = frames[i+1];
            let y2 = [ [frame2[0][1]], [frame2[1][1]], [frame2[2][1]] ];
            let scaled_y2 = mul_matrix_scalar(y2, 0.02);
            let scaled_y_n2 = mul_matrix_scalar(y2, -0.02);

            engine.draw_debug_line(vec3s[i], vec3s[i+1], false, 0.005, 0x222222);
            engine.draw_debug_line(vec3s[i], add_matrix_matrix(vec3s[i], scaled_y), false, 0.002, 0x666666);
            engine.draw_debug_line(vec3s[i], add_matrix_matrix(vec3s[i], scaled_y_n), false, 0.002, 0x777777);

            // engine.draw_debug_line(add_matrix_matrix(points[i], scaled_y), add_matrix_matrix(points[i+1], scaled_y2), false, 0.002, 0x777777);
            // engine.draw_debug_line(add_matrix_matrix(points[i], scaled_y_n), add_matrix_matrix(points[i+1], scaled_y_n2), false, 0.002, 0x777777);
        }

        for(let i = 0; i < vec3s.length; i+=3) {
            let p = unroll_matrix_to_list(vec3s[i]);
            if (p[2] > 0) {
                engine.draw_debug_line(p, [p[0], p[1], 0], false, 0.01, 0x9999bb);
            }
        }


    });

</script>
</body>
</html>