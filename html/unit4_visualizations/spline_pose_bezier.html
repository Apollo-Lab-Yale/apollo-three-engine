<!DOCTYPE html>
<html lang="en">
<head>
    <title>CPSC 487/587</title>
    <script src="../../js/setup/setup_mathjax.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.3.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quaternion@1.5.1/quaternion.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric-1.2.6.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js"></script>
    <script type="importmap">
        {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
              "three/": "https://unpkg.com/three@0.160.0/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import {ThreeEngine} from "../../js/utils/utils_three.js";
    import {TransformGizmoEngine} from "../../js/utils/utils_transform_gizmo.js";
    import {identity_matrix} from "../../js/utils/utils_math.js";
    import {ln_SO3_and_t_to_so3_and_v, so3_and_v_to_vec6, exp_so3_and_v_to_SO3_and_t, vec6_to_so3_and_v} from "../../js/utils/utils_exp_and_log.js";
    import {BezierSplineSegment, PolynomialBasedSpline} from "../../js/utils/utils_splines.js";
    import {mul_matrix_scalar} from "../../js/utils/utils_math.js";
    import {add_matrix_matrix} from "../../js/utils/utils_math.js";
    import {get_default_lil_gui} from "../../js/utils/utils_three.js";
    import {set_object_pose_from_SO3_matrix_and_position} from "../../js/utils/utils_transforms.js";
    import {refresh_displays} from "../../js/utils/utils_three.js";

    let engine = ThreeEngine.new_default_3d(6, 3, 3);
    engine.add_suzanne_monkey_as_mesh_object(0x00eeff);

    let tge = new TransformGizmoEngine(engine);

    let settings = {
        t: 0,
        is_playing: false,
        toggle: false
    };

    let actions = {
        play: () => {
            settings.is_playing = true;
        },
        stop: () => {
            settings.is_playing = false;
        },
        toggle_transform_gizmo_mode: () => {
            settings.toggle = true;
        }
    }

    let gui = get_default_lil_gui();
    gui.add(settings, 't', 0, 0.9999999);
    gui.add(actions, 'toggle_transform_gizmo_mode').name('Toggle transform gizmo mode');
    gui.add(actions, 'play').name('Play');
    gui.add(actions, 'stop').name('Stop');

    tge.add_gizmo_SO3_matrix_and_position(engine, identity_matrix(3), [3,0,0], 0.4);
    tge.add_gizmo_SO3_matrix_and_position(engine, identity_matrix(3), [0,3,0], 0.4);
    tge.add_gizmo_SO3_matrix_and_position(engine, identity_matrix(3), [0,-3,0], 0.4);
    tge.add_gizmo_SO3_matrix_and_position(engine, identity_matrix(3), [-3,0,0], 0.4);

    let p1 = tge.get_gizmo_pose_as_SO3_matrix_and_position(0);
    let ln1 = ln_SO3_and_t_to_so3_and_v(p1[0], p1[1]);
    let v1 = so3_and_v_to_vec6(ln1[0], ln1[1]);

    let p2 = tge.get_gizmo_pose_as_SO3_matrix_and_position(1);
    let ln2 = ln_SO3_and_t_to_so3_and_v(p2[0], p2[1]);
    let v2 = so3_and_v_to_vec6(ln2[0], ln2[1]);

    let p3 = tge.get_gizmo_pose_as_SO3_matrix_and_position(2);
    let ln3 = ln_SO3_and_t_to_so3_and_v(p3[0], p3[1]);
    let v3 = so3_and_v_to_vec6(ln3[0], ln3[1]);

    let p4 = tge.get_gizmo_pose_as_SO3_matrix_and_position(3);
    let ln4 = ln_SO3_and_t_to_so3_and_v(p4[0], p4[1]);
    let v4 = so3_and_v_to_vec6(ln4[0], ln4[1]);

    let spline_seg = new BezierSplineSegment(6, [ v1, v2, v3, v4 ]);
    let spline = new PolynomialBasedSpline([spline_seg]);

    // let ss = vec6_to_so3_and_v(v1);
    // let exp1 = exp_so3_and_v_to_SO3_and_t(ss[0], ss[1]);

    engine.animation_loop(function() {
        if(settings.toggle) {
            tge.toggle_mode();
            settings.toggle = false;
        }

        if(settings.is_playing) {
            settings.t += 0.005;
            if(settings.t > spline.max_interpolation_value()) { settings.t = 0; }
            refresh_displays(gui);
        }


        let p1 = tge.get_gizmo_pose_as_SO3_matrix_and_position(0);
        let ln1 = ln_SO3_and_t_to_so3_and_v(p1[0], p1[1]);
        let v1 = so3_and_v_to_vec6(ln1[0], ln1[1]);

        let p2 = tge.get_gizmo_pose_as_SO3_matrix_and_position(1);
        let ln2 = ln_SO3_and_t_to_so3_and_v(p2[0], p2[1]);
        let v2 = so3_and_v_to_vec6(ln2[0], ln2[1]);

        let p3 = tge.get_gizmo_pose_as_SO3_matrix_and_position(2);
        let ln3 = ln_SO3_and_t_to_so3_and_v(p3[0], p3[1]);
        let v3 = so3_and_v_to_vec6(ln3[0], ln3[1]);

        let p4 = tge.get_gizmo_pose_as_SO3_matrix_and_position(3);
        let ln4 = ln_SO3_and_t_to_so3_and_v(p4[0], p4[1]);
        let v4 = so3_and_v_to_vec6(ln4[0], ln4[1]);

        spline.segments[0].update_control_point(0, v1);
        spline.segments[0].update_control_point(1, v2);
        spline.segments[0].update_control_point(2, v3);
        spline.segments[0].update_control_point(3, v4);

        engine.draw_debug_line(p1[1], p2[1], false, 0.003, 0x888888);
        engine.draw_debug_line(p3[1], p4[1], false, 0.003, 0x888888);

        let poses = [];
        for(let i = 0; i <= 100; i++) {
            let t = i / 100;
            t = Math.min(t, 0.999999);
            let v = spline.interpolate(t);
            let ss = vec6_to_so3_and_v(v);
            let exp = exp_so3_and_v_to_SO3_and_t(ss[0], ss[1]);
            poses.push(exp);
        }

        for(let i = 0; i < poses.length-1; i++) {
            let p1 = poses[i];
            let p2 = poses[i+1];
            let pos1 = p1[1];
            let pos2 = p2[1];

            engine.draw_debug_line(pos1, pos2, false, 0.005, 0x333333);

            let r1 = p1[0];
            let r2 = p2[0];

            let x1 = [ [r1[0][1]], [r1[1][1]], [r1[2][1]] ];
            let x2 = [ [r2[0][1]], [r2[1][1]], [r2[2][1]] ];
            let scaled_x1 = mul_matrix_scalar(x1, 0.4);
            let scaled_x2 = mul_matrix_scalar(x2, 0.4);
            let n_scaled_x1 = mul_matrix_scalar(scaled_x1, -1);
            let n_scaled_x2 = mul_matrix_scalar(scaled_x2, -1);

            engine.draw_debug_line(pos1, add_matrix_matrix(pos1, scaled_x1), false, 0.0015, 0x333333);
            engine.draw_debug_line(pos1, add_matrix_matrix(pos1, n_scaled_x1), false, 0.0015, 0x333333);

            engine.draw_debug_line(add_matrix_matrix(pos1, scaled_x1), add_matrix_matrix(pos2, scaled_x2), false, 0.006, 0x333333);
            engine.draw_debug_line(add_matrix_matrix(pos1, n_scaled_x1), add_matrix_matrix(pos2, n_scaled_x2), false, 0.006, 0x333333);
        }


        let t = settings.t;
        let v = spline.interpolate(t);
        let ss = vec6_to_so3_and_v(v);
        let exp = exp_so3_and_v_to_SO3_and_t(ss[0], ss[1]);
        set_object_pose_from_SO3_matrix_and_position(engine, 0, exp[0], exp[1]);

    });

</script>
</body>
</html>